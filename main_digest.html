<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Anatomy Annotator</title>
    <!-- Métadonnées et icônes -->
    <meta name="theme-color" content="#0A1A3A" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta
      name="description"
      content="Une application pour annoter des images anatomiques avec des masques et des catégories prédéfinies."
    />
    <link
      rel="apple-touch-icon"
      href="https://placehold.co/180x180/0A1A3A/FFFFFF?text=AA"
      sizes="180x180"
      type="image/png"
    />
    <link
      rel="icon"
      href="https://placehold.co/48x48/0A1A3A/FFFFFF?text=AA"
      sizes="48x48"
      type="image/png"
    />

    <!-- Polices et icônes -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
      rel="stylesheet"
      crossorigin="anonymous"
    />

    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css"
      rel="stylesheet"
      crossorigin="anonymous"
    />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
      /* --- Variables CSS Globales --- */
      :root {
        /* Thème Sombre (Défaut) */
        --color-background: #000000;
        --color-text: #eaeaea;
        --color-text-muted: #a0a0a0;
        --glass-bg: rgba(15, 15, 20, 0.5);
        --border-color: rgba(255, 255, 255, 0.1);
        --toolbar-btn-bg: rgba(255, 255, 255, 0.05);
        --toolbar-btn-hover-bg: rgba(255, 255, 255, 0.1);
        --toolbar-btn-color: #ffffff;
        --background-image-url: url("dark_mode_gradient.png");
        --modal-bg: rgba(0, 0, 0, 0.8);
        --history-item-hover: rgba(255, 255, 255, 0.05);
        --label-bg: rgba(15, 15, 20, 0.7);

        /* Couleurs partagées */
        --gradient-primary: linear-gradient(135deg, #ff7d12, #fb3aa2, #2997ff);
        --glow-color: rgba(251, 58, 162, 0.3);
        --border-color-hover: #fb3aa2;
        --glass-blur: blur(12px);
      }

      body.light-mode {
        /* Thème Clair */
        --color-background: #f0f2f5;
        --color-text: #1c1e21;
        --color-text-muted: #65676b;
        --glass-bg: rgba(255, 255, 255, 0.6);
        --border-color: rgba(0, 0, 0, 0.1);
        --toolbar-btn-bg: rgba(0, 0, 0, 0.05);
        --toolbar-btn-hover-bg: rgba(0, 0, 0, 0.1);
        --toolbar-btn-color: #1c1e21;
        --background-image-url: url("light_mode_gradient.png");
        --modal-bg: rgba(255, 255, 255, 0.8);
        --history-item-hover: rgba(0, 0, 0, 0.05);
        --label-bg: rgba(255, 255, 255, 0.8);
      }

      /* --- Réinitialisation et Styles de Base --- */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html {
        height: 100%;
      }
      body {
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        font-family: "Inter", sans-serif;
        color: var(--color-text);
        -webkit-tap-highlight-color: transparent;
        background-color: var(--color-background);
        background-image: var(--background-image-url);
        background-repeat: no-repeat;
        background-position: bottom center;
        background-size: 100% auto;
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      /* --- En-tête --- */
      .top-header {
        position: fixed;
        top: 15px;
        left: 20px;
        z-index: 10;
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--color-text-muted);
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .top-header .app-title {
        background-image: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        font-weight: 600;
      }

      /* --- Conteneur Principal --- */
      .main-container {
        display: flex;
        gap: 1.5rem;
        padding: 60px 1.5rem 1.5rem;
        height: 100%;
        width: 100%;
        align-items: flex-start;
        justify-content: center;
      }

      /* --- Colonne du Canvas --- */
      .canvas-column {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        height: 100%;
        max-width: 1200px;
        min-height: 0;
      }
      .canvas-wrapper {
        flex-grow: 1;
        position: relative;
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--border-color);
        border-radius: 16px;
        padding: 0.75rem;
        display: flex;
        min-height: 0;
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }
      .canvas-area {
        position: relative;
        width: 100%;
        height: 100%;
        border-radius: 8px;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #canvas {
        max-width: 100%;
        max-height: 100%;
        cursor: crosshair;
        display: none;
        touch-action: none;
      }
      #noImagePlaceholder {
        text-align: center;
        color: var(--color-text-muted);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      #noImagePlaceholder h5 {
        font-size: 1.1rem;
        font-weight: 500;
        color: var(--color-text);
        margin-bottom: 0.5rem;
      }

      /* --- Barres d'outils --- */
      .toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.6rem;
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--border-color);
        border-radius: 16px;
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }
      .toolbar-group {
        display: flex;
        gap: 0.6rem;
        align-items: center;
      }
      .toolbar-btn {
        width: 42px;
        height: 42px;
        border-radius: 10px;
        background: var(--toolbar-btn-bg);
        border: 1px solid var(--border-color);
        color: var(--toolbar-btn-color);
        font-size: 1.1rem;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .toolbar-btn:hover:not(:disabled) {
        border-color: var(--border-color-hover);
        background: var(--toolbar-btn-hover-bg);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px var(--glow-color);
      }
      .toolbar-btn.active {
        background-image: var(--gradient-primary);
        color: #ffffff;
        border-color: transparent;
        box-shadow: 0 0 15px var(--glow-color);
      }
      .toolbar-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .read-only-badge {
        background-color: #ffcc00;
        color: #333;
        padding: 4px 8px;
        border-radius: 6px;
        font-size: 0.7em;
        font-weight: 700;
        display: none;
        align-items: center;
        gap: 5px;
      }
      .read-only-badge.active {
        display: flex;
      }

      /* --- Panneau de Catégories --- */
      .category-panel {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        padding: 1rem;
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        -webkit-backdrop-filter: var(--glass-blur);
        border: 1px solid var(--border-color);
        border-radius: 16px;
        width: 260px;
        flex-shrink: 0;
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }
      .category-btn {
        font-family: "Inter", sans-serif;
        font-weight: 500;
        font-size: 0.9rem;
        text-align: left;
        color: var(--color-text);
        padding: 0.8rem 1.2rem;
        border-radius: 10px;
        background-color: var(--toolbar-btn-bg);
        border: 1px solid var(--border-color);
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .category-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        filter: brightness(1.2);
        border-color: rgba(255, 255, 255, 0.2);
      }

      body.light-mode .category-btn:hover:not(:disabled) {
        border-color: rgba(0, 0, 0, 0.2);
      }

      .category-btn.active {
        color: white;
        border-color: transparent;
        box-shadow: 0 0 15px var(--glow-color);
      }
      .category-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
        filter: none;
        border-color: var(--border-color);
      }
      #cat3.active {
        background-image: linear-gradient(135deg, #ff3333, #cc0000);
      }
      #cat4.active {
        background-image: linear-gradient(135deg, #33cc33, #008000);
      }
      #cat5.active {
        background-image: linear-gradient(135deg, #027541, #005a32);
      }
      #cat7.active {
        background-image: linear-gradient(135deg, #9f33ff, #7e00d1);
      }
      #cat6.active {
        background-image: linear-gradient(135deg, #b3b3b3, #808080);
      }
      #cat8.active {
        background-image: linear-gradient(135deg, #ff9933, #d97506);
      }

      /* --- Modales --- */
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: var(--modal-bg);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }
      .modal-overlay.active {
        opacity: 1;
        pointer-events: all;
      }
      #confirmModal.modal-overlay,
      #imageChangeModal.modal-overlay {
        z-index: 1002;
      }
      .modal-content {
        background: var(--glass-bg);
        border: 1px solid var(--border-color);
        border-radius: 16px;
        padding: 1.5rem;
        width: 90%;
        max-width: 500px;
        transform: scale(0.95);
        transition: transform 0.3s ease, background-color 0.3s ease,
          border-color 0.3s ease;
        color: var(--color-text);
        display: flex;
        flex-direction: column;
        max-height: 80vh;
      }
      .modal-overlay.active .modal-content {
        transform: scale(1);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        flex-shrink: 0;
      }
      .modal-title {
        font-size: 1.2rem;
        font-weight: 600;
      }
      .modal-body {
        margin-bottom: 1.5rem;
        color: var(--color-text-muted);
        line-height: 1.6;
        overflow-y: auto;
        flex-grow: 1;
      }
      .modal-body strong {
        color: var(--color-text);
      }
      .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
        flex-shrink: 0;
      }
      .btn-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        color: var(--color-text-muted);
        cursor: pointer;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      .btn-close:hover {
        opacity: 1;
      }
      .btn {
        padding: 0.6rem 1.2rem;
        border-radius: 8px;
        font-weight: 500;
        border: 1px solid transparent;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .btn-primary {
        background-image: var(--gradient-primary);
        color: white;
      }
      .btn-primary:hover {
        filter: brightness(1.2);
        box-shadow: 0 0 15px var(--glow-color);
      }
      .btn-secondary {
        background: var(--toolbar-btn-bg);
        border-color: var(--border-color);
        color: var(--color-text);
      }
      .btn-secondary:hover {
        background: var(--toolbar-btn-hover-bg);
      }

      /* --- Historique --- */
      #historyList {
        list-style: none;
        padding: 0;
      }
      .history-item {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 10px;
        border-bottom: 1px solid var(--border-color);
        cursor: pointer;
        transition: background-color 0.2s;
        border-radius: 8px;
      }
      .history-item:hover {
        background-color: var(--history-item-hover);
      }
      .history-item-thumbnail {
        width: 80px;
        height: 60px;
        object-fit: cover;
        border-radius: 6px;
        flex-shrink: 0;
      }
      .history-item-info {
        flex-grow: 1;
        font-size: 0.9rem;
      }
      .history-item-info span {
        display: block;
      }
      .history-item-info .filename {
        font-weight: 600;
        color: var(--color-text);
      }
      .history-item-info .details {
        font-size: 0.8rem;
      }
      .history-item-delete {
        color: var(--color-text-muted);
        cursor: pointer;
        transition: color 0.2s;
        font-size: 1rem;
        padding: 5px;
      }
      .history-item-delete:hover {
        color: #ff5555;
      }

      /* --- Messages et Indicateurs --- */
      .message-box {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 20px;
        border-radius: 8px;
        z-index: 1003;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s, visibility 0.3s;
        font-size: 0.9rem;
        text-align: center;
      }
      .message-box.active {
        opacity: 1;
        visibility: visible;
      }

      .no-annotation-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        color: white;
        padding: 20px 30px;
        border-radius: 12px;
        font-size: 1.5rem;
        font-weight: bold;
        text-align: center;
        pointer-events: none;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s, visibility 0.3s;
        z-index: 50;
      }
      .no-annotation-message.active {
        opacity: 1;
        visibility: visible;
      }

      .progress-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        z-index: 1001;
        display: none;
        align-items: center;
        justify-content: center;
      }
      .progress-overlay.active {
        display: flex;
      }
      .progress-spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid var(--border-color-hover);
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
      }

      body.light-mode .progress-spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        border-top-color: var(--border-color-hover);
      }

      @keyframes spin {
        100% {
          transform: rotate(360deg);
        }
      }

      .light-mode .draw-label {
        background-color: var(--label-bg);
      }

      /* --- Responsive --- */
      @media (max-width: 1024px) {
        .main-container {
          flex-direction: column;
          padding: 60px 1rem 1rem;
        }
        .category-panel {
          width: 100%;
          flex-direction: row;
          flex-wrap: wrap;
          max-height: 25vh;
          overflow-y: auto;
        }
        .category-btn {
          flex-grow: 1;
          text-align: center;
        }
      }
      @media (max-width: 768px) {
        .top-header {
          font-size: 0.8rem;
          top: 10px;
          left: 10px;
        }
        .main-container {
          padding: 50px 0.5rem 0.5rem;
          gap: 1rem;
        }
        .toolbar,
        .bottom-toolbar {
          padding: 0.4rem;
        }
        .toolbar-btn {
          width: 38px;
          height: 38px;
          font-size: 1rem;
        }
        .category-panel {
          padding: 0.75rem;
          gap: 0.5rem;
        }
        .category-btn {
          padding: 0.6rem 0.8rem;
          font-size: 0.8rem;
        }
        .bottom-toolbar {
          bottom: 0.75rem;
          right: 0.75rem;
          gap: 0.5rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="top-header">
      <span class="app-title">Anatomy Annotator</span>
      <span class="brand">by Vioo AI</span>
    </div>

    <div class="progress-overlay" id="progressOverlay">
      <div class="progress-spinner"></div>
    </div>

    <div class="main-container">
      <!-- Colonne principale avec le canvas et les outils -->
      <div class="canvas-column">
        <div class="toolbar">
          <div class="toolbar-group">
            <button
              class="toolbar-btn"
              id="newImageBtn"
              title="Charger une image"
            >
              <i class="fas fa-download"></i>
            </button>
            <button
              class="toolbar-btn"
              id="saveBtn"
              title="Enregistrer les annotations"
            >
              <i class="fas fa-save"></i>
            </button>
            <button class="toolbar-btn" id="historyBtn" title="Historique">
              <i class="fas fa-history"></i>
            </button>
            <button
              class="toolbar-btn"
              id="toggleAnnotationsBtn"
              title="Afficher/Masquer les annotations"
            >
              <i class="fas fa-eye"></i>
            </button>
            <span class="read-only-badge" id="readOnlyBadge"
              ><i class="fas fa-lock"></i> LECTURE SEULE</span
            >
          </div>
          <div class="toolbar-group">
            <button class="toolbar-btn" id="tutorialBtn" title="Aide">
              <i class="fas fa-question-circle"></i>
            </button>
            <!-- BOUTON DE THÈME AJOUTÉ ICI -->
            <button
              class="toolbar-btn"
              id="themeToggleBtn"
              title="Passer en mode clair"
            >
              <i class="fas fa-sun"></i>
            </button>
            <button class="toolbar-btn" id="backBtn" title="Retour">
              <i class="fas fa-arrow-left"></i>
            </button>
            <!-- NOUVEL EMPLACEMENT DES BOUTONS UNDO/REDO/CLEAR -->
            <button class="toolbar-btn" id="undoBtn" title="Annuler (Ctrl+Z)">
              <i class="fas fa-undo"></i>
            </button>
            <button class="toolbar-btn" id="redoBtn" title="Refaire (Ctrl+Y)">
              <i class="fas fa-redo"></i>
            </button>
            <button class="toolbar-btn" id="clearAllBtn" title="Tout effacer">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        </div>

        <div class="canvas-wrapper">
          <div id="noAnnotationMessage" class="no-annotation-message">
            Pas d'annotations. Dessinez pour enregistrer !
          </div>
          <div class="canvas-area">
            <div id="noImagePlaceholder">
              <h5>Prêt à disséquer ?</h5>
              <p>Chargez une image pour commencer.</p>
            </div>
            <canvas id="canvas"></canvas>
          </div>
        </div>
      </div>

      <!-- Panneau des catégories -->
      <div class="category-panel">
        <button class="category-btn" id="cat3" data-category="3">
          Artère Cystique
        </button>
        <button class="category-btn" id="cat4" data-category="4">
          Canal Cystique
        </button>
        <button class="category-btn" id="cat5" data-category="5">
          Vésicule Biliaire
        </button>
        <button class="category-btn" id="cat7" data-category="7">Foie</button>
        <button class="category-btn" id="cat6" data-category="6">Outil</button>
        <button class="category-btn" id="cat8" data-category="8">
          Voie Biliaire Principale
        </button>
      </div>
    </div>

    <!-- Input caché pour le chargement de fichier -->
    <input type="file" id="imageInput" accept="image/*" style="display: none" />

    <!-- Modales -->
    <div class="modal-overlay" id="tutorialModal">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Instructions</h5>
          <button class="btn-close" data-dismiss="modal">&times;</button>
        </div>
        <div class="modal-body">
          <p>
            <strong>1. Charger :</strong> Importez une image via
            <i class="fas fa-download"></i> ou par glisser-déposer.
          </p>
          <p>
            <strong>2. Choisir :</strong> Sélectionnez une catégorie
            d'annotation sur la droite.
          </p>
          <p>
            <strong>3. Annoter :</strong> Maintenez le clic ou le toucher pour
            dessiner le contour. Relâchez pour finaliser.
          </p>
          <p>
            <strong>4. Gérer :</strong> Utilisez les outils
            <i class="fas fa-undo"></i>, <i class="fas fa-redo"></i>, et
            <i class="fas fa-trash"></i> pour modifier vos annotations.
          </p>
          <p>
            <strong>5. Sauvegarder :</strong> Enregistrez votre travail via
            <i class="fas fa-save"></i>.
          </p>
        </div>
        <div class="modal-footer">
          <button class="btn btn-primary" data-dismiss="modal">
            Compris !
          </button>
        </div>
      </div>
    </div>

    <div class="modal-overlay" id="confirmModal">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="confirmModalLabel">Confirmation</h5>
          <button class="btn-close" data-dismiss="modal">&times;</button>
        </div>
        <div class="modal-body"><p id="confirmMessage"></p></div>
        <div class="modal-footer">
          <button class="btn btn-secondary" data-dismiss="modal">
            Annuler
          </button>
          <button class="btn btn-primary" id="confirmActionBtn">
            Confirmer
          </button>
        </div>
      </div>
    </div>

    <div class="modal-overlay" id="imageChangeModal">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Changer d'image</h5>
          <button class="btn-close" data-dismiss="modal">&times;</button>
        </div>
        <div class="modal-body">
          <p>
            Voulez-vous enregistrer les annotations actuelles avant de continuer
            ?
          </p>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" data-dismiss="modal">
            Annuler
          </button>
          <button class="btn btn-primary" id="saveAndChangeBtn">
            Enregistrer et changer
          </button>
          <button class="btn btn-primary" id="changeWithoutSavingBtn">
            Changer sans enregistrer
          </button>
        </div>
      </div>
    </div>

    <div class="modal-overlay" id="historyModal">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">Historique des annotations</h5>
          <button class="btn-close" data-dismiss="modal">&times;</button>
        </div>
        <div class="modal-body"><ul id="historyList"></ul></div>
        <div class="modal-footer">
          <button class="btn btn-secondary" id="clearHistoryBtn">
            Vider l'historique
          </button>
          <button class="btn btn-primary" data-dismiss="modal">Fermer</button>
        </div>
      </div>
    </div>

    <script>
      class AnatomyAnnotator {
        /**
         * Constructeur de la classe AnatomyAnnotator.
         * Initialise la configuration, l'état, les éléments du DOM et le contexte du canvas.
         */
        constructor() {
          this.config = {
            // Définition statique des catégories d'annotation
            CATEGORIES: {
              3: {
                id: 3,
                name: "cystic_artery",
                color: "rgb(255, 51, 51)",
                supercategory: "anatomy",
                displayName: "Artère Cystique",
              },
              4: {
                id: 4,
                name: "cystic_duct",
                color: "rgb(51, 204, 51)",
                supercategory: "anatomy",
                displayName: "Canal Cystique",
              },
              5: {
                id: 5,
                name: "gallbladder",
                color: "rgb(0, 90, 50)",
                supercategory: "anatomy",
                displayName: "Vésicule Biliaire",
              },
              6: {
                id: 6,
                name: "tool",
                color: "rgb(179, 179, 179)",
                supercategory: "tool",
                displayName: "Outil",
              },
              7: {
                id: 7,
                name: "liver",
                color: "rgb(159, 51, 255)",
                supercategory: "anatomy",
                displayName: "Foie",
              },
              8: {
                id: 8,
                name: "common_bile_duct",
                color: "rgb(255, 153, 51)",
                supercategory: "anatomy",
                displayName: "Voie Biliaire Principale",
              },
            },
            IMAGE_WIDTH: 1920, // Largeur cible pour les images importées
            IMAGE_HEIGHT: 1080, // Hauteur cible pour les images importées
          };

          // Centralisation de tous les éléments du DOM
          this.dom = {
            body: document.body,
            canvas: document.getElementById("canvas"),
            canvasArea: document.querySelector(".canvas-area"),
            placeholder: document.getElementById("noImagePlaceholder"),
            progressOverlay: document.getElementById("progressOverlay"),
            imageInput: document.getElementById("imageInput"),
            readOnlyBadge: document.getElementById("readOnlyBadge"),
            noAnnotationMessage: document.getElementById("noAnnotationMessage"),
            // Modales
            tutorialModal: document.getElementById("tutorialModal"),
            confirmModal: document.getElementById("confirmModal"),
            imageChangeModal: document.getElementById("imageChangeModal"),
            historyModal: document.getElementById("historyModal"),
            // Éléments des modales
            confirmModalLabel: document.getElementById("confirmModalLabel"),
            confirmMessage: document.getElementById("confirmMessage"),
            confirmActionBtn: document.getElementById("confirmActionBtn"),
            saveAndChangeBtn: document.getElementById("saveAndChangeBtn"),
            changeWithoutSavingBtn: document.getElementById(
              "changeWithoutSavingBtn"
            ),
            historyList: document.getElementById("historyList"),
            clearHistoryBtn: document.getElementById("clearHistoryBtn"),
            // Boutons de la barre d'outils
            newImageBtn: document.getElementById("newImageBtn"),
            saveBtn: document.getElementById("saveBtn"),
            historyBtn: document.getElementById("historyBtn"),
            toggleAnnotationsBtn: document.getElementById(
              "toggleAnnotationsBtn"
            ),
            tutorialBtn: document.getElementById("tutorialBtn"),
            themeToggleBtn: document.getElementById("themeToggleBtn"), // Bouton de thème
            backBtn: document.getElementById("backBtn"),
            undoBtn: document.getElementById("undoBtn"),
            redoBtn: document.getElementById("redoBtn"),
            clearAllBtn: document.getElementById("clearAllBtn"),
            categoryPanel: document.querySelector(".category-panel"),
          };

          this.ctx = this.dom.canvas.getContext("2d", {
            willReadFrequently: true,
          });

          // Initialisation de l'état de l'application
          this.resetState();
        }

        /**
         * Réinitialise l'état de l'application à ses valeurs par défaut.
         * Appelé lors du chargement d'une nouvelle image ou à l'initialisation.
         */
        resetState() {
          this.state = {
            image: null,
            annotations: [],
            history: [[]], // L'historique commence avec un état vide (un tableau d'annotations vide)
            historyIndex: 0, // Pointe vers l'état actuel dans l'historique
            currentCategory: 3,
            maskPoints: [],
            isDrawing: false,
            showAnnotations: true,
            isSaved: true,
            isViewOnly: false,
            currentImageRenderInfo: { x: 0, y: 0, width: 0, height: 0 },
          };
        }

        /**
         * Point d'entrée principal. Configure les écouteurs d'événements et initialise l'UI.
         */
        init() {
          this.loadTheme();
          this.setupEventListeners();
          this.updateUIState();
        }

        // --- GESTION DES ÉVÉNEMENTS ---

        /**
         * Configure tous les écouteurs d'événements de l'application.
         */
        setupEventListeners() {
          // Modales
          document.querySelectorAll('[data-dismiss="modal"]').forEach((btn) => {
            btn.addEventListener("click", () =>
              btn.closest(".modal-overlay").classList.remove("active")
            );
          });

          // Barre d'outils principale
          this.dom.newImageBtn.onclick = () =>
            this.checkUnsavedChanges(() => this.dom.imageInput.click());
          this.dom.imageInput.onchange = (e) =>
            e.target.files[0] && this.loadImage(e.target.files[0]);
          this.dom.saveBtn.onclick = () => this.saveAll();
          this.dom.historyBtn.onclick = () => this.showHistoryModal();
          this.dom.clearHistoryBtn.onclick = () => this.clearAllHistory();
          this.dom.backBtn.onclick = () =>
            this.checkUnsavedChanges(
              () => (window.location.href = "index.html")
            );
          this.dom.toggleAnnotationsBtn.onclick = () =>
            this.toggleAnnotationsVisibility();
          this.dom.tutorialBtn.onclick = () =>
            this.toggleModal("tutorialModal", true);
          this.dom.themeToggleBtn.onclick = () => this.toggleTheme();

          // Barre d'outils du canvas (undo, redo, clear)
          this.dom.undoBtn.onclick = () => this.undo();
          this.dom.redoBtn.onclick = () => this.redo();
          this.dom.clearAllBtn.onclick = () => this.clearAll();

          // Catégories
          this.dom.categoryPanel.addEventListener("click", (e) => {
            if (e.target.classList.contains("category-btn")) {
              this.selectCategory(e.target.dataset.category);
            }
          });

          // Canvas (dessin)
          const canvas = this.dom.canvas;
          canvas.addEventListener("mousedown", this.handleDrawStart.bind(this));
          canvas.addEventListener("mousemove", this.handleDrawMove.bind(this));
          canvas.addEventListener("mouseup", this.handleDrawEnd.bind(this));
          canvas.addEventListener("mouseleave", this.handleDrawEnd.bind(this));
          canvas.addEventListener(
            "touchstart",
            this.handleDrawStart.bind(this),
            { passive: false }
          );
          canvas.addEventListener("touchmove", this.handleDrawMove.bind(this), {
            passive: false,
          });
          canvas.addEventListener("touchend", this.handleDrawEnd.bind(this), {
            passive: false,
          });
          canvas.addEventListener("contextmenu", (e) => e.preventDefault());

          // Glisser-déposer
          const canvasArea = this.dom.canvasArea;
          ["dragenter", "dragover", "dragleave", "drop"].forEach((evt) => {
            canvasArea.addEventListener(
              evt,
              (e) => {
                e.preventDefault();
                e.stopPropagation();
              },
              false
            );
          });
          canvasArea.addEventListener("drop", (e) => {
            const file = e.dataTransfer.files[0];
            this.checkUnsavedChanges(() => this.loadImage(file));
          });

          // Raccourcis clavier
          window.addEventListener("keydown", (e) => {
            if (document.querySelector(".modal-overlay.active")) return;
            if (e.ctrlKey && e.key === "z") this.undo();
            if (e.ctrlKey && e.key === "y") this.redo();
          });

          // Redimensionnement de la fenêtre
          window.addEventListener(
            "resize",
            this.debounce(() => this.initializeCanvas(), 200)
          );
        }

        // --- GESTION DU THÈME ---

        /**
         * Charge le thème (clair/sombre) depuis le localStorage au démarrage.
         */
        loadTheme() {
          const theme = localStorage.getItem("theme") || "dark";
          if (theme === "light") {
            this.dom.body.classList.add("light-mode");
          }
          this.updateThemeIcon();
        }

        /**
         * Bascule entre le thème clair et sombre.
         */
        toggleTheme() {
          this.dom.body.classList.toggle("light-mode");
          const theme = this.dom.body.classList.contains("light-mode")
            ? "light"
            : "dark";
          localStorage.setItem("theme", theme);
          this.updateThemeIcon();
          this.redrawCanvas(); // Redessiner pour mettre à jour les couleurs des labels
        }

        /**
         * Met à jour l'icône et le titre du bouton de thème.
         */
        updateThemeIcon() {
          const isLight = this.dom.body.classList.contains("light-mode");
          const icon = this.dom.themeToggleBtn.querySelector("i");
          icon.className = isLight ? "fas fa-moon" : "fas fa-sun";
          this.dom.themeToggleBtn.title = isLight
            ? "Passer en mode sombre"
            : "Passer en mode clair";
        }

        // --- LOGIQUE DE L'APPLICATION ---

        /**
         * Charge et redimensionne une image fournie par l'utilisateur.
         * @param {File} file - Le fichier image à charger.
         */
        loadImage(file) {
          if (!file || !file.type.startsWith("image/")) return;
          this.setProgress(true);
          const reader = new FileReader();
          reader.onload = (e) => {
            const imgElement = new Image();
            imgElement.onload = () => {
              const tempCanvas = document.createElement("canvas");
              const tempCtx = tempCanvas.getContext("2d");
              tempCanvas.width = this.config.IMAGE_WIDTH;
              tempCanvas.height = this.config.IMAGE_HEIGHT;
              tempCtx.drawImage(
                imgElement,
                0,
                0,
                tempCanvas.width,
                tempCanvas.height
              );
              const resizedDataURL = tempCanvas.toDataURL(file.type);

              const resizedImgElement = new Image();
              resizedImgElement.onload = () => {
                this.resetState();
                this.state.image = {
                  file_name: file.name,
                  dataURL: resizedDataURL,
                  image: resizedImgElement,
                  id: Date.now(),
                  height: resizedImgElement.height,
                  width: resizedImgElement.width,
                  annotationIndex: 0,
                };
                this.initializeCanvas();
                this.updateUIState();
                this.setProgress(false);
              };
              resizedImgElement.src = resizedDataURL;
            };
            imgElement.src = e.target.result;
          };
          reader.readAsDataURL(file);
        }

        /**
         * Charge une image et ses annotations depuis l'historique local.
         * @param {object} historyEntry - L'objet d'historique à charger.
         */
        loadImageFromHistory(historyEntry) {
          this.setProgress(true);
          const imgElement = new Image();
          imgElement.onload = () => {
            this.resetState();
            this.state.isViewOnly = true;
            this.state.image = {
              file_name: historyEntry.fileName,
              dataURL: historyEntry.imageData,
              image: imgElement,
              id: historyEntry.imageId,
              height: imgElement.height,
              width: imgElement.width,
            };

            // Charger les annotations et mettre à jour l'historique
            const loadedAnnotations = JSON.parse(
              JSON.stringify(historyEntry.annotations)
            );
            this.state.annotations = loadedAnnotations;
            this.state.history = [[...loadedAnnotations]]; // Initialise l'historique avec cet état
            this.state.historyIndex = 0;

            this.state.image.annotationIndex =
              loadedAnnotations.reduce(
                (max, anno) => Math.max(max, anno.id % 1000),
                0
              ) + 1;

            this.initializeCanvas();
            this.updateUIState();
            this.setProgress(false);
          };
          imgElement.src = historyEntry.imageData;
        }

        /**
         * Sélectionne une catégorie d'annotation.
         * @param {string|number} id - L'ID de la catégorie à sélectionner.
         */
        selectCategory(id) {
          if (this.state.isViewOnly) return;
          this.state.currentCategory = parseInt(id, 10);
          document.querySelectorAll(".category-btn").forEach((btn) => {
            btn.classList.toggle(
              "active",
              parseInt(btn.dataset.category, 10) === this.state.currentCategory
            );
          });
        }

        // --- GESTION DE L'HISTORIQUE (UNDO/REDO) ---

        /**
         * Enregistre l'état actuel des annotations dans l'historique.
         * Cela permet les fonctionnalités d'annulation et de rétablissement.
         */
        recordState() {
          this.state.isSaved = false;
          // Crée une copie profonde des annotations actuelles
          const currentState = JSON.parse(
            JSON.stringify(this.state.annotations)
          );

          // Si on a fait des "undo", on supprime les états futurs avant d'ajouter le nouvel état
          this.state.history = this.state.history.slice(
            0,
            this.state.historyIndex + 1
          );

          this.state.history.push(currentState);
          this.state.historyIndex++;

          this.updateUIState(); // Met à jour l'état des boutons undo/redo
        }

        /**
         * Annule la dernière action en revenant à l'état précédent dans l'historique.
         */
        undo() {
          if (this.state.isViewOnly) return;
          if (this.state.historyIndex > 0) {
            this.state.historyIndex--;
            this.state.annotations = JSON.parse(
              JSON.stringify(this.state.history[this.state.historyIndex])
            );
            this.redrawCanvas();
            this.updateUIState();
          }
        }

        /**
         * Rétablit l'action précédemment annulée.
         */
        redo() {
          if (this.state.isViewOnly) return;
          if (this.state.historyIndex < this.state.history.length - 1) {
            this.state.historyIndex++;
            this.state.annotations = JSON.parse(
              JSON.stringify(this.state.history[this.state.historyIndex])
            );
            this.redrawCanvas();
            this.updateUIState();
          }
        }

        /**
         * Efface toutes les annotations du canvas après confirmation.
         */
        clearAll() {
          if (this.state.isViewOnly || this.state.annotations.length === 0)
            return;

          this.showConfirmModal(
            "Tout effacer",
            "Voulez-vous vraiment supprimer toutes les annotations ?",
            () => {
              if (this.state.annotations.length > 0) {
                this.state.annotations = [];
                this.recordState(); // Enregistre l'état vide dans l'historique
                this.redrawCanvas();
              }
            }
          );
        }

        // --- DESSIN SUR LE CANVAS ---

        /**
         * Gère le début du dessin (clic ou toucher).
         * @param {Event} e - L'événement de la souris ou du toucher.
         */
        handleDrawStart(e) {
          if (this.state.isViewOnly || !this.state.image) return;
          e.preventDefault();
          const pos = this.getTransformedPos(
            e.clientX ?? e.touches[0].clientX,
            e.clientY ?? e.touches[0].clientY
          );
          if (!pos) return;
          this.state.isDrawing = true;
          this.state.maskPoints = [pos];
        }

        /**
         * Gère le mouvement pendant le dessin.
         * @param {Event} e - L'événement de la souris ou du toucher.
         */
        handleDrawMove(e) {
          if (!this.state.isDrawing) return;
          e.preventDefault();
          const pos = this.getTransformedPos(
            e.clientX ?? e.touches[0].clientX,
            e.clientY ?? e.touches[0].clientY
          );
          if (!pos) return;
          this.state.maskPoints.push(pos);
          this.redrawCanvas();
        }

        /**
         * Gère la fin du dessin (relâchement du clic ou du toucher).
         */
        handleDrawEnd() {
          if (!this.state.isDrawing) return;
          this.state.isDrawing = false;
          this.finalizeMask();
        }

        /**
         * Finalise le masque dessiné, le transforme en annotation et l'ajoute à la liste.
         */
        finalizeMask() {
          if (this.state.maskPoints.length < 3) {
            this.state.maskPoints = [];
            this.redrawCanvas();
            return;
          }
          const { image, currentImageRenderInfo, currentCategory } = this.state;
          const scaleX = image.width / currentImageRenderInfo.width;
          const scaleY = image.height / currentImageRenderInfo.height;

          const segmentation = [[]];
          let minX = Infinity,
            minY = Infinity,
            maxX = -Infinity,
            maxY = -Infinity;

          this.state.maskPoints.forEach((p) => {
            const originalX = Math.round(p.x * scaleX);
            const originalY = Math.round(p.y * scaleY);
            segmentation[0].push(originalX, originalY);
            minX = Math.min(minX, originalX);
            minY = Math.min(minY, originalY);
            maxX = Math.max(maxX, originalX);
            maxY = Math.max(maxY, originalY);
          });

          this.state.annotations.push({
            id: image.id * 1000 + image.annotationIndex++,
            image_id: image.id,
            category_id: currentCategory,
            bbox: [minX, minY, maxX - minX, maxY - minY],
            area: 0, // Le calcul de l'aire peut être ajouté ici si nécessaire
            segmentation: segmentation,
            iscrowd: 0,
          });

          this.state.maskPoints = [];
          this.recordState(); // Enregistre le nouvel état avec l'annotation ajoutée
          this.redrawCanvas();
        }

        /**
         * Redessine l'intégralité du canvas : image de fond, annotations et masque en cours.
         */
        redrawCanvas() {
          if (!this.state.image) return;
          const { canvas } = this.dom;
          const { image } = this.state;

          this.ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Calculer les dimensions de l'image pour qu'elle remplisse le canvas (comportement 'cover')
          const imgRatio = image.width / image.height;
          const canvasRatio = canvas.width / canvas.height;
          let dw, dh, dx, dy;

          if (imgRatio > canvasRatio) {
            // L'image est plus large que le canvas (relativement)
            // On fait correspondre la hauteur de l'image à la hauteur du canvas
            dh = canvas.height;
            dw = dh * imgRatio;
            // On centre l'image horizontalement, en rognant les côtés
            dx = (canvas.width - dw) / 2;
            dy = 0;
          } else {
            // L'image est plus haute que le canvas (relativement)
            // On fait correspondre la largeur de l'image à la largeur du canvas
            dw = canvas.width;
            dh = dw / imgRatio;
            // On centre l'image verticalement, en rognant le haut/bas
            dx = 0;
            dy = (canvas.height - dh) / 2;
          }

          this.state.currentImageRenderInfo = {
            x: dx,
            y: dy,
            width: dw,
            height: dh,
          };
          this.ctx.drawImage(image.image, dx, dy, dw, dh);

          const labelRects = [];
          if (this.state.showAnnotations) {
            this.state.annotations.forEach((anno) =>
              this.drawAnnotation(anno, labelRects)
            );
          }
          if (this.state.isDrawing && this.state.maskPoints.length > 0) {
            this.drawCurrentMask();
          }
        }

        // --- FONCTIONS DE DESSIN SPÉCIFIQUES ---

        drawAnnotation(anno, labelRects) {
          const category = this.config.CATEGORIES[anno.category_id];
          if (!category) return;

          const { currentImageRenderInfo, image } = this.state;
          const scaleX = currentImageRenderInfo.width / image.width;
          const scaleY = currentImageRenderInfo.height / image.height;
          const scaledMask = anno.segmentation[0].map((val, i) =>
            i % 2 === 0
              ? val * scaleX + currentImageRenderInfo.x
              : val * scaleY + currentImageRenderInfo.y
          );

          this.ctx.fillStyle = category.color
            .replace("rgb", "rgba")
            .replace(")", ", 0.3)");
          this.ctx.strokeStyle = category.color;
          this.ctx.lineWidth = 2;

          this.drawPolygon(scaledMask);
          this.drawLabel(
            category.displayName,
            scaledMask,
            category,
            labelRects
          );
        }

        drawPolygon(points) {
          if (points.length < 2) return;
          this.ctx.beginPath();
          this.ctx.moveTo(points[0], points[1]);
          for (let i = 2; i < points.length; i += 2) {
            this.ctx.lineTo(points[i], points[i + 1]);
          }
          this.ctx.closePath();
          this.ctx.fill();
          this.ctx.stroke();
        }

        drawLabel(text, scaledMaskPoints, category, labelRects) {
          const fontSize = 12;
          this.ctx.font = `bold ${fontSize}px Inter`;
          const padding = 4;
          const textMetrics = this.ctx.measureText(text);
          const rectWidth = textMetrics.width + padding * 2;
          const rectHeight = fontSize + padding * 2;

          let minX = Infinity,
            maxX = -Infinity,
            minY = Infinity;
          for (let i = 0; i < scaledMaskPoints.length; i += 2) {
            minX = Math.min(minX, scaledMaskPoints[i]);
            maxX = Math.max(maxX, scaledMaskPoints[i]);
            minY = Math.min(minY, scaledMaskPoints[i + 1]);
          }

          let labelX = (minX + maxX) / 2 - rectWidth / 2;
          let labelY = minY - rectHeight - 5;

          // Assurer que le label reste dans les limites du canvas
          labelX = Math.max(
            padding,
            Math.min(labelX, this.dom.canvas.width - rectWidth - padding)
          );
          labelY = Math.max(
            padding,
            Math.min(labelY, this.dom.canvas.height - rectHeight - padding)
          );

          // Éviter le chevauchement basique
          if (
            labelRects.some(
              (r) =>
                labelX < r.x + r.width &&
                labelX + rectWidth > r.x &&
                labelY < r.y + r.height &&
                labelY + rectHeight > r.y
            )
          ) {
            labelY = Math.max(minY, labelY) + rectHeight + 5;
          }
          labelRects.push({
            x: labelX,
            y: labelY,
            width: rectWidth,
            height: rectHeight,
          });

          this.ctx.fillStyle = getComputedStyle(
            document.documentElement
          ).getPropertyValue("--label-bg");
          this.ctx.fillRect(labelX, labelY, rectWidth, rectHeight);
          this.ctx.fillStyle = category.color;
          this.ctx.textBaseline = "top";
          this.ctx.fillText(text, labelX + padding, labelY + padding);
        }

        drawCurrentMask() {
          this.ctx.strokeStyle =
            this.config.CATEGORIES[this.state.currentCategory].color;
          this.ctx.lineWidth = 2;
          this.ctx.beginPath();
          this.state.maskPoints.forEach((p, i) => {
            const drawX = p.x + this.state.currentImageRenderInfo.x;
            const drawY = p.y + this.state.currentImageRenderInfo.y;
            i === 0
              ? this.ctx.moveTo(drawX, drawY)
              : this.ctx.lineTo(drawX, drawY);
          });
          this.ctx.stroke();
        }

        // --- GESTION DE L'UI ---

        /**
         * Met à jour l'état de l'interface utilisateur (activation/désactivation des boutons, etc.).
         */
        updateUIState() {
          const { image, isViewOnly, history, historyIndex, annotations } =
            this.state;
          const hasImage = !!image;
          const canAnnotate = hasImage && !isViewOnly;

          this.dom.canvas.style.display = hasImage ? "block" : "none";
          this.dom.placeholder.style.display = hasImage ? "none" : "flex";

          // Activer/désactiver les boutons en fonction de l'état
          this.dom.saveBtn.disabled = !hasImage || annotations.length === 0;
          this.dom.clearAllBtn.disabled =
            !canAnnotate || annotations.length === 0;
          this.dom.undoBtn.disabled = !canAnnotate || historyIndex <= 0;
          this.dom.redoBtn.disabled =
            !canAnnotate || historyIndex >= history.length - 1;

          document
            .querySelectorAll(".category-btn")
            .forEach((btn) => (btn.disabled = !canAnnotate));
          this.dom.readOnlyBadge.classList.toggle("active", isViewOnly);

          if (isViewOnly) {
            document
              .querySelectorAll(".category-btn.active")
              .forEach((b) => b.classList.remove("active"));
          } else if (hasImage) {
            this.selectCategory(this.state.currentCategory);
          }
        }

        /**
         * Initialise ou redimensionne le canvas pour qu'il s'adapte à son conteneur.
         */
        initializeCanvas() {
          if (!this.state.image) return;
          this.dom.canvas.width = this.dom.canvasArea.clientWidth;
          this.dom.canvas.height = this.dom.canvasArea.clientHeight;
          this.redrawCanvas();
        }

        /**
         * Affiche ou masque les annotations sur le canvas.
         */
        toggleAnnotationsVisibility() {
          this.state.showAnnotations = !this.state.showAnnotations;
          this.dom.toggleAnnotationsBtn.querySelector(
            "i"
          ).className = `fas fa-eye${
            this.state.showAnnotations ? "" : "-slash"
          }`;
          this.redrawCanvas();
        }

        // --- SAUVEGARDE ET HISTORIQUE LOCAL ---

        /**
         * Convertit les annotations actuelles au format de segmentation YOLO.
         * @returns {string} Une chaîne contenant les données au format YOLO.
         */
        convertToYOLOFormat() {
          const { annotations, image } = this.state;
          if (!image || annotations.length === 0) {
            return "";
          }

          const { width: imgW, height: imgH } = image;

          // Crée un mappage des ID de catégorie (3, 4, 5...) vers des index YOLO (0, 1, 2...)
          // C'est crucial car YOLO attend des index commençant à 0.
          const yoloIdMap = new Map([
            // [ID_application, ID_YOLO]
            [3, 2], // Artère Cystique (id: 3) -> YOLO ID 2
            [4, 3], // Canal Cystique (id: 4) -> YOLO ID 3
            [5, 4], // Vésicule Biliaire (id: 5) -> YOLO ID 4
            [6, 5], // Outil (id: 6) -> YOLO ID 5
            [7, 6], // Foie (id: 7) -> YOLO ID 6
            [8, 7], // Voie Biliaire Principale (id: 8) -> YOLO ID 7
          ]);

          const yoloLines = annotations.map((anno) => {
            const yoloClassId = yoloIdMap.get(anno.category_id);
            if (yoloClassId === undefined) return null; // Ignorer si la catégorie n'est pas mappée

            // Prendre les points de segmentation [x1, y1, x2, y2, ...]
            const segmentationPoints = anno.segmentation[0];
            const normalizedPoints = [];

            // Normaliser chaque point par la largeur/hauteur de l'image
            for (let i = 0; i < segmentationPoints.length; i += 2) {
              const x = segmentationPoints[i];
              const y = segmentationPoints[i + 1];
              normalizedPoints.push(parseFloat((x / imgW).toFixed(4)));
              normalizedPoints.push(parseFloat((y / imgH).toFixed(4)));
            }

            return `${yoloClassId} ${normalizedPoints.join(" ")}`;
          });

          return yoloLines.filter(Boolean).join("\n"); // Retourne toutes les lignes jointes par un saut de ligne
        }

        // --- SAUVEGARDE ET HISTORIQUE LOCAL ---
        /**
         * Sauvegarde les annotations actuelles dans un fichier JSON et met à jour l'historique local.
         */
        /**
         * Sauvegarde tout dans une archive ZIP :
         * 1. Image originale (redimensionnée 1920x1080)
         * 2. Image avec annotations (export du canvas)
         * 3. Fichier JSON (format COCO)
         * 4. Fichier TXT (format YOLO segmentation)
         */
        async saveAll() {
          if (!this.state.image || this.state.annotations.length === 0) {
            this.showNoAnnotationMessage();
            return;
          }
          this.setProgress(true);

          try {
            const zip = new JSZip(); // Initialise JSZip
            const baseFilename = this.state.image.file_name.split(".")[0];
            const imageExtension =
              this.state.image.file_name.split(".").pop() || "jpg";

            // 1. Ajouter le fichier JSON (comme avant)
            const jsonData = {
              images: [
                {
                  file_name: this.state.image.file_name,
                  height: this.state.image.height,
                  width: this.state.image.width,
                  id: this.state.image.id,
                },
              ],
              annotations: this.state.annotations,
              categories: Object.values(this.config.CATEGORIES),
            };
            zip.file(
              `${baseFilename}_annotations.json`,
              JSON.stringify(jsonData, null, 2)
            );

            // 2. Ajouter le fichier TXT au format YOLO
            const yoloData = this.convertToYOLOFormat();
            if (yoloData) {
              zip.file(`${baseFilename}.txt`, yoloData);
            }

            // 3. Ajouter l'image originale (celle chargée dans l'app)
            // On extrait les données base64 du dataURL
            const originalImageBase64 = this.state.image.dataURL.split(",")[1];
            zip.file(this.state.image.file_name, originalImageBase64, {
              base64: true,
            });

            // 4. Ajouter l'image annotée (depuis le canvas)
            const annotatedImageDataUrl =
              this.dom.canvas.toDataURL("image/png");
            const annotatedImageBase64 = annotatedImageDataUrl.split(",")[1];
            zip.file(`${baseFilename}_annotated.png`, annotatedImageBase64, {
              base64: true,
            });

            // 5. Générer le ZIP et le télécharger
            const content = await zip.generateAsync({ type: "blob" });
            const a = document.createElement("a");
            a.href = URL.createObjectURL(content);
            a.download = `${baseFilename}.zip`; // Le fichier final est un .zip
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);

            // Mise à jour de l'historique local (inchangé)
            const historyEntry = {
              fileName: this.state.image.file_name,
              imageData: this.state.image.dataURL,
              annotations: this.state.annotations,
              imageId: this.state.image.id,
              timestamp: new Date().toISOString(),
            };
            let history = this.getHistory().filter(
              (item) => item.fileName !== historyEntry.fileName
            );
            history.push(historyEntry);
            this.saveHistory(history);

            this.state.isSaved = true;
          } catch (error) {
            console.error("Erreur lors de la création du ZIP:", error);
            // Gérer l'erreur, peut-être afficher un message à l'utilisateur
          } finally {
            this.setProgress(false);
          }
        }

        getHistory = () =>
          JSON.parse(localStorage.getItem("annotatedImageHistory")) || [];
        saveHistory = (history) => {
          if (history.length > 10) history = history.slice(-10);
          localStorage.setItem(
            "annotatedImageHistory",
            JSON.stringify(history)
          );
        };

        // --- MODALES ET UTILITAIRES ---

        toggleModal = (modalId, show) =>
          document.getElementById(modalId).classList.toggle("active", show);
        setProgress = (active) =>
          this.dom.progressOverlay.classList.toggle("active", active);
        debounce = (func, wait) => {
          let timeout;
          return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
          };
        };

        showConfirmModal(title, message, confirmCallback) {
          this.dom.confirmModalLabel.textContent = title;
          this.dom.confirmMessage.textContent = message;

          // Remplacer le bouton pour éviter les écouteurs multiples
          const newConfirmBtn = this.dom.confirmActionBtn.cloneNode(true);
          this.dom.confirmActionBtn.parentNode.replaceChild(
            newConfirmBtn,
            this.dom.confirmActionBtn
          );
          this.dom.confirmActionBtn = newConfirmBtn;

          this.dom.confirmActionBtn.onclick = () => {
            confirmCallback();
            this.toggleModal("confirmModal", false);
          };
          this.toggleModal("confirmModal", true);
        }

        showHistoryModal() {
          this.dom.historyList.innerHTML = "";
          const history = this.getHistory();
          this.dom.clearHistoryBtn.style.display =
            history.length > 0 ? "block" : "none";

          if (history.length === 0) {
            this.dom.historyList.innerHTML =
              "<li>Aucune image dans l'historique.</li>";
          } else {
            history.reverse().forEach((entry) => {
              const li = document.createElement("li");
              li.className = "history-item";
              li.innerHTML = `
                        <img src="${
                          entry.imageData
                        }" class="history-item-thumbnail" alt="Aperçu"/>
                        <div class="history-item-info">
                            <span class="filename">${entry.fileName}</span>
                            <span class="details">${
                              entry.annotations.length
                            } annotation(s) - ${new Date(
                entry.timestamp
              ).toLocaleString()}</span>
                        </div>
                        <i class="fas fa-trash history-item-delete" title="Supprimer cette entrée"></i>`;

              li.querySelector(".history-item-delete").onclick = (e) => {
                e.stopPropagation();
                this.deleteHistoryEntry(entry.timestamp);
              };
              li.addEventListener("click", () =>
                this.checkUnsavedChanges(() => {
                  this.loadImageFromHistory(entry);
                  this.toggleModal("historyModal", false);
                })
              );
              this.dom.historyList.appendChild(li);
            });
          }
          this.toggleModal("historyModal", true);
        }

        deleteHistoryEntry(timestamp) {
          this.showConfirmModal(
            "Supprimer l'entrée",
            "Voulez-vous vraiment supprimer cette entrée ?",
            () => {
              let history = this.getHistory().filter(
                (item) => item.timestamp !== timestamp
              );
              this.saveHistory(history);
              this.showHistoryModal();
            }
          );
        }

        clearAllHistory() {
          this.showConfirmModal(
            "Vider l'historique",
            "Voulez-vous vraiment vider tout l'historique ?",
            () => {
              localStorage.removeItem("annotatedImageHistory");
              this.showHistoryModal();
            }
          );
        }

        checkUnsavedChanges(callback) {
          if (this.state.image && !this.state.isSaved) {
            this.toggleModal("imageChangeModal", true);
            this.dom.saveAndChangeBtn.onclick = () => {
              this.saveAll();
              setTimeout(() => {
                callback();
                this.toggleModal("imageChangeModal", false);
              }, 100);
            };
            this.dom.changeWithoutSavingBtn.onclick = () => {
              this.state.isSaved = true;
              callback();
              this.toggleModal("imageChangeModal", false);
            };
          } else {
            callback();
          }
        }

        showNoAnnotationMessage = (duration = 3000) => {
          this.dom.noAnnotationMessage.classList.add("active");
          setTimeout(
            () => this.dom.noAnnotationMessage.classList.remove("active"),
            duration
          );
        };

        getTransformedPos(clientX, clientY) {
          const rect = this.dom.canvas.getBoundingClientRect();
          const { currentImageRenderInfo, canvas } = this.state;
          // Calcul original basé sur l'image affichée (currentImageRenderInfo)
          const x =
            (clientX - rect.left) * (this.dom.canvas.width / rect.width) -
            this.state.currentImageRenderInfo.x;
          const y =
            (clientY - rect.top) * (this.dom.canvas.height / rect.height) -
            this.state.currentImageRenderInfo.y;

          // Vérifier si le clic est à l'intérieur des limites de l'image affichée
          if (
            x < 0 ||
            y < 0 ||
            x > this.state.currentImageRenderInfo.width ||
            y > this.state.currentImageRenderInfo.height
          ) {
            return null;
          }
          return { x, y };
        }
      }

      // Point d'entrée de l'application
      document.addEventListener("DOMContentLoaded", () => {
        const app = new AnatomyAnnotator();
        app.init();
      });
    </script>
  </body>
</html>

